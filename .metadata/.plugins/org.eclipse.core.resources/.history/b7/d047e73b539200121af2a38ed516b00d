package fivedot1;
/**
 * You are given two 32-bit numbers, N and M, and two bit positions, i and j. 
 * Write a method to insert M into N such that M starts at bit j and ends at bit i.
 *  You can assume that the bits j through i have enough space to fit all of M. That
 *   is, if M=10011, you can assume that there are at least 5 bits between j and i.
 *    You would not, for example, have j = 3 and i=2, because M could not fully fit 
 *    between bit 3 and bit 2. 
 *    EXAMPLE
 *    Input: N = 10000000000, M = 10011, i = 2, j = 6
 *    Output: N = 10001001100
 * @author gengchen
 *
 */

public class InsertBits {
	public static void main(String[] args) throws Exception{
//		int N = 512;
//		int M = 19;
//		int NN = InsertBits(N,M,2,6);
//		System.out.println("N = " + Integer.toBinaryString(N) + ", M = " + Integer.toBinaryString(M) + ", after the insertion, N becaomes " + Integer.toBinaryString(NN));
		int i = 3;
		System.out.println(updateBit(i,2,1));
	}
	
	public static int InsertBits(int N, int M, int i , int j) throws Exception{
		String str = Integer.toBinaryString(M);
		int size = str.length();;
		if (j - i + 1 < size)
			throw new Exception("illegal opeation");
		for( int k = 0; k < size ; k++){
			int v = getBit(M,k);
			updateBit(N,i,v);
			i++;
		}
		return N;
	}
	public static int getBit(int num,int i){
		int mask = 1 << i;
		return (mask & num) >> i;
	}
	public static int setBit(int num, int i){ 
		int mask = 1 << i;
		return mask | num;
	}
	
	public static int clearBit(int num ,int i){
		int mask = ~(1 << i);
		return mask & num;
	}
	
	public static int clearBitsMSBthroughI(int num, int i){
		int mask = ( 1 << i ) - 1;
		return num & mask;
	}
	
	public static int clearBitsIthrough0(int num, int i){
		int mask = ~((1 << (i + 1)) -1 );
		return mask & num;
	}
	public static int updateBit(int num , int i , int v){
		int mask = ~(1 << i);
		return (num & mask) | (v << i);
		
	}

}
